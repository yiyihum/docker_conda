diff --git a/verde/__init__.py b/verde/__init__.py
index 6c4e8f6..505fb9c 100644
--- a/verde/__init__.py
+++ b/verde/__init__.py
@@ -5,7 +5,7 @@ from ._version import get_versions as _get_versions
 
 # Import functions/classes to make the API
 from .utils import scatter_points, grid_coordinates, profile_coordinates, \
-    block_reduce, block_region, inside
+    block_reduce, block_region, inside, get_region
 from . import datasets
 from .scipy_bridge import ScipyGridder
 
diff --git a/verde/base/gridder.py b/verde/base/gridder.py
index 58b7ad1..5789398 100644
--- a/verde/base/gridder.py
+++ b/verde/base/gridder.py
@@ -212,7 +212,7 @@ class BaseGridder(BaseEstimator):
         raise NotImplementedError()
 
     def grid(self, region=None, shape=None, spacing=None, adjust='spacing',
-             dims=None, data_names=None):
+             dims=None, data_names=None, projection=None):
         """
         Interpolate the data onto a regular grid.
 
@@ -278,7 +278,10 @@ class BaseGridder(BaseEstimator):
         region = get_region(self, region)
         easting, northing = grid_coordinates(region, shape=shape,
                                              spacing=spacing, adjust=adjust)
-        data = check_data(self.predict(easting, northing))
+        if projection is None:
+            data = check_data(self.predict(easting, northing))
+        else:
+            data = check_data(self.predict(*projection(easting, northing)))
         coords = {dims[1]: easting[0, :], dims[0]: northing[:, 0]}
         attrs = {'metadata': 'Generated by {}'.format(repr(self))}
         data_vars = {name: (dims, value, attrs)
@@ -286,7 +289,7 @@ class BaseGridder(BaseEstimator):
         return xr.Dataset(data_vars, coords=coords, attrs=attrs)
 
     def scatter(self, region=None, size=300, random_state=0, dims=None,
-                data_names=None):
+                data_names=None, projection=None):
         """
         Interpolate values onto a random scatter of points.
 
@@ -331,17 +334,16 @@ class BaseGridder(BaseEstimator):
         data_names = get_data_names(self, data_names)
         region = get_region(self, region)
         east, north = scatter_points(region, size, random_state)
-        data = check_data(self.predict(east, north))
-        column_names = [dim for dim in dims]
-        column_names.extend(data_names)
-        columns = [north, east]
-        columns.extend(data)
-        table = pd.DataFrame(
-            {name: value for name, value in zip(column_names, columns)},
-            columns=column_names)
-        return table
-
-    def profile(self, point1, point2, size, dims=None, data_names=None):
+        if projection is None:
+            data = check_data(self.predict(east, north))
+        else:
+            data = check_data(self.predict(*projection(east, north)))
+        columns = [(dims[0], north), (dims[1], east)]
+        columns.extend(zip(data_names, data))
+        return pd.DataFrame(dict(columns), columns=[c[0] for c in columns])
+
+    def profile(self, point1, point2, size, dims=None, data_names=None,
+                projection=None):
         """
         Interpolate data along a profile between two points.
 
@@ -388,13 +390,10 @@ class BaseGridder(BaseEstimator):
         data_names = get_data_names(self, data_names)
         east, north, distances = profile_coordinates(
             point1, point2, size, coordinate_system=coordsys)
-        data = check_data(self.predict(east, north))
-        column_names = [dim for dim in dims]
-        column_names.append('distance')
-        column_names.extend(data_names)
-        columns = [north, east, distances]
-        columns.extend(data)
-        table = pd.DataFrame(
-            {name: value for name, value in zip(column_names, columns)},
-            columns=column_names)
-        return table
+        if projection is None:
+            data = check_data(self.predict(east, north))
+        else:
+            data = check_data(self.predict(*projection(east, north)))
+        columns = [(dims[0], north), (dims[1], east), ('distance', distances)]
+        columns.extend(zip(data_names, data))
+        return pd.DataFrame(dict(columns), columns=[c[0] for c in columns])

