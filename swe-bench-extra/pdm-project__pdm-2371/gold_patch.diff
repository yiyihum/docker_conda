diff --git a/news/2273.enhancement.md b/news/2273.enhancement.md
deleted file mode 100644
index c740a83f..00000000
--- a/news/2273.enhancement.md
+++ /dev/null
@@ -1,2 +0,0 @@
-Add test coverage entrypoint in `pyproject.toml`
-Improve test coverage for untested functions in `pdm.utils`
\ No newline at end of file
diff --git a/news/2286.refactor.md b/news/2286.refactor.md
deleted file mode 100644
index affeceec..00000000
--- a/news/2286.refactor.md
+++ /dev/null
@@ -1,1 +0,0 @@
-Refactor `find_project_root()` and `find_pypackage()` to look for the project root recursively, and remove the `project_max_depth` configuration variable and the corresponding `PDM_PROJECT_MAX_DEPTH` environment variable.
diff --git a/news/2369.bugfix.md b/news/2369.bugfix.md
new file mode 100644
index 00000000..e903cda3
--- /dev/null
+++ b/news/2369.bugfix.md
@@ -0,0 +1,1 @@
+Fix a resolution issue that extra dependencies are not resolved when the bare dependency has more specific version constraint.
diff --git a/src/pdm/formats/requirements.py b/src/pdm/formats/requirements.py
index 1da87490..6cdfc89b 100644
--- a/src/pdm/formats/requirements.py
+++ b/src/pdm/formats/requirements.py
@@ -183,13 +183,18 @@ def export(
     from pdm.models.candidates import Candidate
 
     lines = ["# This file is @generated by PDM.\n# Please do not edit it manually.\n\n"]
+    collected_req: set[str] = set()
     for candidate in sorted(candidates, key=lambda x: x.identify()):  # type: ignore[attr-defined]
         if isinstance(candidate, Candidate):
             req = dataclasses.replace(candidate.req, specifier=get_specifier(f"=={candidate.version}"), marker=None)
         else:
             assert isinstance(candidate, Requirement)
             req = candidate
+        line = project.backend.expand_line(req.as_line(), options.expandvars)
+        if line in collected_req:
+            continue
         lines.append(project.backend.expand_line(req.as_line(), options.expandvars))
+        collected_req.add(line)
         if options.hashes and getattr(candidate, "hashes", None):
             for item in sorted({row["hash"] for row in candidate.hashes}):  # type: ignore[attr-defined]
                 lines.append(f" \\\n    --hash={item}")
diff --git a/src/pdm/models/candidates.py b/src/pdm/models/candidates.py
index bd7213bb..434df1ac 100644
--- a/src/pdm/models/candidates.py
+++ b/src/pdm/models/candidates.py
@@ -175,6 +175,16 @@ class Candidate:
     def identify(self) -> str:
         return self.req.identify()
 
+    def copy_with(self, requirement: Requirement) -> Candidate:
+        can = Candidate(requirement, name=self.name, version=self.version, link=self.link)
+        can.summary = self.summary
+        can.hashes = self.hashes
+        can._requires_python = self._requires_python
+        can._prepared = self._prepared
+        if can._prepared:
+            can._prepared.req = requirement
+        return can
+
     @property
     def dep_key(self) -> tuple[str, str | None]:
         """Key for retrieving and storing dependencies from the provider.
diff --git a/src/pdm/models/repositories.py b/src/pdm/models/repositories.py
index bb0c6e88..6fd07fbc 100644
--- a/src/pdm/models/repositories.py
+++ b/src/pdm/models/repositories.py
@@ -601,8 +601,7 @@ class LockedRepository(BaseRepository):
             if not requirement.name:
                 # make sure can.identify() won't return a randomly-generated name
                 requirement.name = can.name
-            can.req = requirement
-            yield can
+            yield can.copy_with(requirement)
 
     def get_hashes(self, candidate: Candidate) -> list[FileHash]:
         return candidate.hashes
diff --git a/src/pdm/resolver/providers.py b/src/pdm/resolver/providers.py
index 757e87b1..4d3345c8 100644
--- a/src/pdm/resolver/providers.py
+++ b/src/pdm/resolver/providers.py
@@ -1,6 +1,5 @@
 from __future__ import annotations
 
-import itertools
 import os
 from typing import TYPE_CHECKING, Callable, cast
 
@@ -159,15 +158,21 @@ class BaseProvider(AbstractProvider):
                 return (c for c in candidates if c not in incompat)
             elif identifier in self.overrides:
                 return iter(self.get_override_candidates(identifier))
-            reqs_iter = requirements[identifier]
+            reqs = sorted(requirements[identifier], key=self.requirement_preference)
+            original_req = reqs[0]
             bare_name, extras = strip_extras(identifier)
             if extras and bare_name in requirements:
                 # We should consider the requirements for both foo and foo[extra]
-                reqs_iter = itertools.chain(reqs_iter, requirements[bare_name])
-            reqs = sorted(reqs_iter, key=self.requirement_preference)
+                reqs.extend(requirements[bare_name])
+                reqs.sort(key=self.requirement_preference)
             candidates = self._find_candidates(reqs[0])
             return (
-                can for can in candidates if can not in incompat and all(self.is_satisfied_by(r, can) for r in reqs)
+                # In some cases we will use candidates from the bare requirement,
+                # this will miss the extra dependencies if any. So we associate the original
+                # requirement back with the candidate since it is used by `get_dependencies()`.
+                can.copy_with(original_req) if extras else can
+                for can in candidates
+                if can not in incompat and all(self.is_satisfied_by(r, can) for r in reqs)
             )
 
         return matches_gen
