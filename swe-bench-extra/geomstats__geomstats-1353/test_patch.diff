diff --git a/tests/parametrizers.py b/tests/parametrizers.py
index b9e40bfb1..1620e59a9 100644
--- a/tests/parametrizers.py
+++ b/tests/parametrizers.py
@@ -50,19 +50,67 @@ def _is_isometry(
 
 
 class Parametrizer(type):
-    """Metaclass for test files.
-
-    Parametrizer decorates every function inside the class with pytest.mark.parametrizer
-    (except class methods and static methods). Two conventions need to be respected:
-
-    1.There should be a TestData object named 'testing_data'.
-    2.Every test function should have its corresponding data function inside
-    TestData object.
-
-    Ex. test_exp() should have method called exp_data() inside 'testing_data'.
+    """Metaclass for test classes.
+
+    Note: A test class is a class that inherits from TestCase.
+    For example, `class TestEuclidean(TestCase)` defines
+    a test class.
+
+    The Parametrizer helps its test class by pairing:
+    - the different test functions of the test class:
+      - e.g. the test function `test_belongs`,
+    - with different test data, generated by auxiliary test data functions
+      - e.g. the test data function `belongs_data` that generates data
+      to test the function `belongs`.
+
+    As such, Parametrizer acts as a "metaclass" of its test class:
+    `class TestEuclidean(TestCase, metaclass=Parametrizer)`.
+
+    Specifically, Parametrizer decorates every test function inside
+    its test class with pytest.mark.parametrizer, with the exception
+    of the test class' class methods and static methods.
+
+    Two conventions need to be respected:
+    1. The test class should contain an attribute named 'testing_data'.
+      - `testing_data` is an object inheriting from `TestData`.
+    2. Every test function should have its corresponding test data function created
+    inside the TestData object called `testing_data`.
+
+    A sample test class looks like this:
+
+    ```
+    class TestEuclidean(TestCase, metaclass=Parametrizer):
+        class TestDataEuclidean(TestData):
+            def belongs_data():
+                ...
+                return self.generate_tests(...)
+        testing_data = TestDataEuclidean()
+        def test_belongs():
+            ...
+    ```
+    Parameters
+    ----------
+    cls : child class of TestCase
+        Test class, i.e. a class inheriting from TestCase
+    name : str
+        Name of the test class
+    bases : TestCase
+        Parent class of the test class: TestCase.
+    attrs : dict
+        Attributes of the test class, for example its methods,
+        stored in a dictionnary as (key, value) when key gives the
+        name of the attribute (for example the name of the method),
+        and value gives the actual attribute (for example the method
+        itself.)
+
+    References
+    ----------
+    More on pytest's parametrizers can be found here:
+    https://docs.pytest.org/en/6.2.x/parametrize.html
     """
 
     def __new__(cls, name, bases, attrs):
+        """Decorate the test class' methods with pytest."""
         for attr_name, attr_value in attrs.copy().items():
             if isinstance(attr_value, types.FunctionType):
                 if ("skip_" + attr_name, True) not in locals()["attrs"].items():
diff --git a/tests/tests_geomstats/test_dirichlet.py b/tests/tests_geomstats/test_dirichlet.py
index ef77fda2a..d7a7b1b6a 100644
--- a/tests/tests_geomstats/test_dirichlet.py
+++ b/tests/tests_geomstats/test_dirichlet.py
@@ -389,3 +389,30 @@ class TestDirichletDistributions(geomstats.tests.TestCase):
         result = helper.test_projection_and_belongs(self.dirichlet, shape)
         for res in result:
             self.assertTrue(res)
+
+    @geomstats.tests.np_and_autograd_only
+    def test_approx_geodesic_bvp(self):
+        """Test approximate solution to geodesic boundary value problem.
+
+        Check that the distance given by the approximate solution is close
+        to the exact solution.
+        """
+        point_a = self.dirichlet.random_point()
+        point_b = self.dirichlet.random_point()
+        res = self.dirichlet.metric._approx_geodesic_bvp(point_a, point_b)
+        result = res[0]
+        expected = self.dirichlet.metric.dist(point_a, point_b)
+        self.assertAllClose(expected, result, atol=0, rtol=1e-1)
+
+    @geomstats.tests.np_and_autograd_only
+    def test_polynomial_init(self):
+        """Test polynomial initialization of the geodesic boundary value problem.
+
+        Check that in a particular case, where linear initialization fails,
+        polynomial initialization gives the desired result.
+        """
+        point_a = gs.array([100.0, 1.0, 1.0])
+        point_b = gs.array([1.0, 1.0, 100.0])
+        result = self.dirichlet.metric.dist(point_a, point_b, init="polynomial")
+        expected = 8.5
+        self.assertAllClose(expected, result, atol=0, rtol=1e-1)
