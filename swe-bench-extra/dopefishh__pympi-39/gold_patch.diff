diff --git a/MANIFEST b/MANIFEST
index 5965331..0b43bb0 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -1,4 +1,5 @@
 # file GENERATED by distutils, do NOT edit
+setup.cfg
 setup.py
 pympi/Elan.py
 pympi/Praat.py
diff --git a/pympi/Elan.py b/pympi/Elan.py
index 4b4553e..0a3975c 100644
--- a/pympi/Elan.py
+++ b/pympi/Elan.py
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
 from xml.etree import cElementTree as etree
-import os
 import re
 import sys
 import time
+import pathlib
 import warnings
 
 VERSION = '1.7'
@@ -663,7 +661,8 @@ class Eaf:
         :returns: Tuple of the form: ``(min_time, max_time)``.
         """
         return (0, 0) if not self.timeslots else\
-            (min(self.timeslots.values()), max(self.timeslots.values()))
+            (min(v for v in self.timeslots.values() if v is not None),
+             max(v for v in self.timeslots.values() if v is not None))
 
     def get_gaps_and_overlaps(self, tier1, tier2, maxlen=-1):
         """Give gaps and overlaps. The return types are shown in the table
@@ -1460,7 +1459,8 @@ def parse_eaf(file_path, eaf_obj, suppress_version_warning=False):
         file_path = sys.stdin
     # Annotation document
     try:
-        tree_root = etree.parse(file_path).getroot()
+        # py3.5 compat: etree.parse does not support pathlib.Path objects in py3.5.
+        tree_root = etree.parse(str(file_path)).getroot()
     except etree.ParseError:
         raise Exception('Unable to parse eaf, can you open it in ELAN?')
 
@@ -1623,15 +1623,7 @@ def to_eaf(file_path, eaf_obj, pretty=True):
     :param bool pretty: Flag to set pretty printing.
     """
     def rm_none(x):
-        try:  # Ugly hack to test if s is a string in py3 and py2
-            basestring
-
-            def isstr(s):
-                return isinstance(s, basestring)
-        except NameError:
-            def isstr(s):
-                return isinstance(s, str)
-        return {k: v if isstr(v) else str(v) for k, v in x.items()
+        return {k: v if isinstance(v, str) else str(v) for k, v in x.items()
                 if v is not None}
     # Annotation Document
     ADOCUMENT = etree.Element('ANNOTATION_DOCUMENT', eaf_obj.adocument)
@@ -1717,7 +1709,8 @@ def to_eaf(file_path, eaf_obj, pretty=True):
         except LookupError:
             sys.stdout.write(etree.tostring(ADOCUMENT, encoding='UTF-8'))
     else:
-        if os.access(file_path, os.F_OK):
-            os.rename(file_path, '{}.bak'.format(file_path))
+        file_path = pathlib.Path(file_path)
+        if file_path.exists():
+            file_path.rename(file_path.with_suffix('.bak'))
         etree.ElementTree(ADOCUMENT).write(
-            file_path, xml_declaration=True, encoding='UTF-8')
+            str(file_path), xml_declaration=True, encoding='UTF-8')
diff --git a/pympi/Praat.py b/pympi/Praat.py
index eba3c5d..9f1ecb6 100644
--- a/pympi/Praat.py
+++ b/pympi/Praat.py
@@ -1,6 +1,3 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
 import codecs
 import re
 import struct
@@ -63,11 +60,9 @@ class TextGrid:
                 elif textlen == -1:
                     textlen = struct.unpack('>h', ifile.read(2))[0]
                     data = ifile.read(textlen*2)
-                    # Hack to go from number to unicode in python3 and python2
-                    fun = unichr if 'unichr' in __builtins__ else chr
                     charlist = (data[i:i+2] for i in range(0, len(data), 2))
-                    return u''.join(
-                        fun(struct.unpack('>h', i)[0]) for i in charlist)
+                    return ''.join(
+                        chr(struct.unpack('>h', i)[0]) for i in charlist)
 
             ifile.read(ord(ifile.read(1)))  # skip oo type
             self.xmin = struct.unpack('>d', ifile.read(8))[0]
@@ -98,9 +93,9 @@ class TextGrid:
                 line = next(ifile).decode(codec)
                 return pat.search(line).group(1)
 
-            regfloat = re.compile('([\d.]+)\s*$', flags=re.UNICODE)
-            regint = re.compile('([\d]+)\s*$', flags=re.UNICODE)
-            regstr = re.compile('"(.*)"\s*$', flags=re.UNICODE)
+            regfloat = re.compile(r'([\d.]+)\s*$', flags=re.UNICODE)
+            regint = re.compile(r'([\d]+)\s*$', flags=re.UNICODE)
+            regstr = re.compile(r'"(.*)"\s*$', flags=re.UNICODE)
             # Skip the Headers and empty line
             next(ifile), next(ifile), next(ifile)
             self.xmin = float(nn(ifile, regfloat))
@@ -159,7 +154,7 @@ class TextGrid:
         elif number < 1 or number > len(self.tiers):
             raise ValueError('Number not in [1..{}]'.format(len(self.tiers)))
         elif tier_type not in Tier.P_TIERS:
-            raise ValueError('tier_type has to be in {}'.format(self.P_TIERS))
+            raise ValueError('tier_type has to be in {}'.format(Tier.P_TIERS))
         self.tiers.insert(number-1,
                           Tier(self.xmin, self.xmax, name, tier_type))
         return self.tiers[number-1]
@@ -254,7 +249,8 @@ class TextGrid:
                         itier and f.write(struct.pack('>d', c[1]))
                         writebstr(c[2 if itier else 1])
         elif mode in ['normal', 'n', 'short', 's']:
-            with codecs.open(filepath, 'w', codec) as f:
+            # py3.5 compat: codecs.open does not support pathlib.Path objects in py3.5.
+            with codecs.open(str(filepath), 'w', codec) as f:
                 short = mode[0] == 's'
 
                 def wrt(indent, prefix, value, ff=''):
diff --git a/pympi/__init__.py b/pympi/__init__.py
index 53f76cc..791f39a 100644
--- a/pympi/__init__.py
+++ b/pympi/__init__.py
@@ -1,5 +1,5 @@
 # Import the packages
 from pympi.Praat import TextGrid
-from pympi.Elan import Eaf
+from pympi.Elan import Eaf, eaf_from_chat
 
 __all__ = ['Praat', 'Elan', 'eaf_from_chat']
diff --git a/tox.ini b/tox.ini
index 142ca55..1ff9207 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,5 +1,5 @@
 [tox]
-envlist = py{36,37,38}
+envlist = py{35,36,37,38}
 skip_missing_interpreters = true
 
 [testenv]
